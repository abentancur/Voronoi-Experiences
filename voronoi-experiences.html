<!DOCTYPE HTML>
<html>
    <head>
        <style>
            body {
                margin: 0px;
                padding: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <div id="container"> </div>

        <script src="http://threejs.org/build/three.min.js"></script>
        <script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script defer="defer">

            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener("keydown", onDocumentKeyPress, false);
            //current path type for new points to follow
            var currentPathtype = "point";
            //a list of all the voronoi cells
            var voronoiMap = [];
            var renderer, camera, scene, controls;
            var lights = [];
            var partyCells = [];
            var parteighMode = false;
            var strobeOn = false;
            var regularLight, blackLight;
            
            init();
            
            // this function is executed on each animation frame
            function animate(){
                // update all the cells in the voronoi map
                var timer = new Date().getTime() * 0.0005;
                
                if (parteighMode) {
                    for (cell of partyCells) {
                        cell.update(timer);
                    }
                } else {
                    for (cell of voronoiMap){
                        cell.update(timer);
                    }
                }

                // render
                render();

                // request new frame
                requestAnimationFrame(function(){
                    animate();
                });
                
                controls.update();
            }
            
            function parteighMovement(){
                var d = Date.now();
                var time = d * 0.00025 * 10;

                if (d % 100 < 20) {
                    scene.remove(blackLight);
                    strobeOn = false;
                } else {
                    if (!strobeOn) {
                        scene.add(blackLight);
                        strobeOn = true;
                    }
                }

                var z = 20, d = 400;
                var startX = window.innerWidth/2;
                var startY = window.innerHeight/2;
                
                lights[0].position.x = startX + Math.sin( time * 0.7 ) * d;
                lights[0].position.y = startX + Math.cos( time * 0.3 ) * d;

                lights[1].position.x = startX + Math.cos( time * 0.3 ) * d;
                lights[1].position.y = startX + Math.sin( time * 0.7 ) * d;

                lights[2].position.x = startX + Math.sin( time * 0.7 ) * d;
                lights[2].position.y = startX + Math.sin( time * 0.5 ) * d;

                lights[3].position.x = startX + Math.sin( time * 0.3 ) * d;
                lights[3].position.y = startX + Math.sin( time * 0.5 ) * d;

                lights[4].position.x = startX + Math.cos( time * 0.3 ) * d;
                lights[4].position.y = startX + Math.sin( time * 0.5 ) * d;

                lights[5].position.x = startX + Math.cos( time * 0.7 ) * d;
                lights[5].position.y = startX + Math.cos( time * 0.5 ) * d;
            }
            
            function render(){
                if (parteighMode) parteighMovement();
                renderer.render(scene, camera);
            }

            function init() {
                // renderer
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // camera
                camera = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, 1, 1000);
                camera.position.z = 700;

                controls = new THREE.OrbitControls(camera);
                controls.damping = 0.2;
                // controls.noKeys = true;
                controls.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, PAN: THREE.MOUSE.MIDDLE };
                controls.addEventListener('change', render);
                
                // scene
                scene = new THREE.Scene();
                
                // Party lights
                var intensity = 2.5;
                var distance = 600;
                // var c = [0xff0040, 0x0040ff, 0x00ff00, 0xffaa00, 0x00ffaa, 0xff1100];
                var c = [0xff0040, 0x00ffff, 0xff0000, 0x7920ff, 0x00ff00, 0x0000ff];
                var startX = window.innerWidth/2;
                var startY = window.innerHeight/2;
                
                var sphere = new THREE.SphereGeometry( 3, 3, 32 );
                
                regularLight = new THREE.AmbientLight( 0xFFFFFF );
                scene.add(regularLight); 
                // blackLight = new THREE.AmbientLight( 0xB364D7 ); 
                blackLight = new THREE.AmbientLight( 0xA700FF )
                // scene.add(blackLight); 
                
                for (var i = 0; i < 6; ++i) {
                    lights[i] = new THREE.PointLight( c[i], intensity, distance );
                    lights[i].add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: c[i] } ) ) );
                    lights[i].position.setX(startX);
                    lights[i].position.setY(startY);
                    lights[i].position.setZ(701);
                    // scene.add( lights[i] );
                }
                
                // set window resize listener
                window.addEventListener('resize', onWindowResize, false);

                // start animation
                animate();
            }
            
            function onDocumentMouseDown(event) {
                if (event.which == 1) {
                    var cell = new voronoiCell(currentPathtype, event.clientX, window.innerHeight - event.clientY);
                    scene.add(cell.sphere);
                    scene.add(cell.cone);
                    voronoiMap.push(cell);
                    if (parteighMode) partyCells.push(cell);
                }
            }
            
            function onDocumentKeyPress(event) {
                var k = event.which || event.keyCode;
                if(k == 67){
                    currentPathtype="circle";
                }
                else if(k == 72){
                    currentPathtype="hline";
                }
                else if(k == 86){
                    currentPathtype="vline";
                }
                else if(k == 85){
                    if (voronoiMap.length > 0) {
                        temp = voronoiMap.pop(); 
                        scene.remove(temp.cone);
                        scene.remove(temp.sphere);
                        if (parteighMode) {
                            temp2 = partyCells.pop();
                            scene.remove(temp2.cone);
                            scene.remove(temp2.sphere);
                        }
                    }
                } 
                else if(k == 80){
                    currentPathtype="point";
                }
                else if(k == 32){
                    controls.reset();
                }
                else if(k == 66){
                    currentPathtype="heart";
                }
                else if(k == 83){
                    currentPathtype="star";
                }
                else if(k == 68){
                    parteighMode = !parteighMode;
                    if (parteighMode) {
                        // Remove the regular cells from the scene
                        for (var i = 0; i < voronoiMap.length; ++i) {
                            var temp = voronoiMap[i];
                            scene.remove(temp.cone);
                            scene.remove(temp.sphere);
                        }
                        // Turn the regular light off
                        scene.remove(regularLight);
                        // Turn the party lights on
                        for (var i = 0; i < lights.length; ++i) {
                            scene.add(lights[i]);
                        }
                        // Turn the blacklight on
                        scene.add(blackLight);
                        // Place the party cells in
                        for (var i = 0; i < voronoiMap.length; ++i) {
                            var temp = voronoiMap[i];
                            var newC = new voronoiCell(temp.pathtype, temp.cx, temp.cy, temp.speed, temp.size);
                            scene.add(newC.cone);
                            scene.add(newC.sphere);
                            partyCells.push(newC);
                        }
                    } else {
                        // Turn blacklight off
                        scene.remove(blackLight);
                        // Remove the party lights
                        for (var i = 0; i < lights.length; ++i) {
                            scene.remove(lights[i]);
                        }
                        // Remove the party cells
                        while (partyCells.length > 0) {
                            var temp = partyCells.pop();
                            scene.remove(temp.cone);
                            scene.remove(temp.sphere);
                        }
                        // Add regular cells back in
                        for (var i = 0; i < voronoiMap.length; ++i) {
                            var temp = voronoiMap[i];
                            scene.add(temp.cone);
                            scene.add(temp.sphere);
                        }
                        // Turn regular light back on
                        scene.add(regularLight);
                    }
                    render();
                }
                else if(k == 37 || k == 38 || k == 39 || k == 40){
                    // handled by orbit controls
                }
                else{
                    alert("Invalid Key!!!\n\nMouseDown to add new particles to the canvus\nPress 'u' to undo\nPress 'p' to change subsequent particles to be static\nPress 'c' to change subsequent particle paths to circles\nPress 'h' to change subsequent particle paths to horizontal lines\nPress 'v' to change subsequent particle paths to vertical lines\nPress 'b' to change subsequent particle paths to a heart curve\nPress 's' to change subsequent particle paths to a star curve (hypocycloid)"); 
                }
            }

            function voronoiCell(pathtype, cx, cy, speed, size) {
                if (typeof speed == 'undefined') { speed = 5; }
                if (typeof size == 'undefined') {size = 50; }
                //the black sphere represents the location for the voronoi cell
                var geometry = new THREE.SphereGeometry( 3, 32, 32 );
                var material = new THREE.MeshBasicMaterial( {color: 0x000000} );
                this.sphere = new THREE.Mesh( geometry, material );
                this.sphere.position.x = cx;
                this.sphere.position.y = cy;
                this.sphere.position.z = 500;
                //the cone represents the voronoi cell
                // var mat = new THREE.MeshBasicMaterial({color: '#'+Math.floor(Math.random()*16777215).toString(16)});
                var mat = new THREE.MeshPhongMaterial({color: '#'+Math.floor(Math.random()*16777215).toString(16), transparent:true, opacity:1.0});
                var rBottom = 1.3*Math.pow(Math.pow(window.innerWidth,2) + Math.pow(window.innerHeight,2), .5);
                this.cone = new THREE.Mesh(new THREE.CylinderGeometry(0, rBottom, 1000, 50, 50, false), mat);
                this.cone.rotation.x += Math.PI/2;
                this.cone.position.x = cx;
                this.cone.position.y = cy;
                this.cone.overdraw = true;
                //other attributes used to move the location along a path
                this.starttime = (new Date()).getTime();
                this.pathtype = pathtype;
                this.speed = speed;
                this.size = size;
                this.cx = cx;
                this.cy = cy;
            }
            
            function onWindowResize() {
                camera.right = window.innerWidth;
                camera.top = window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.render(scene, camera);
            }

            voronoiCell.prototype.update = function(timer){
                var t = this.starttime + timer * this.speed;
                if(this.pathtype == "circle"){
                    this.cone.position.x = this.cx + Math.cos( t ) * this.size;
                    this.cone.position.y = this.cy + Math.sin( t ) * this.size;
                }
                else if(this.pathtype == "hline"){
                    this.cone.position.x = this.cx + Math.cos( t ) * this.size;
                }
                else if(this.pathtype == "vline"){
                    this.cone.position.y = this.cy + Math.sin( t ) * this.size;
                }
                else if(this.pathtype == "heart"){
                    this.cone.position.x = this.cx + ( 16*Math.pow( Math.sin(t), 3 ) ) * 5;
                    this.cone.position.y = this.cy + ( 13*Math.cos( t ) - 5*Math.cos( 2*t ) - 2 * Math.cos( 3*t ) - Math.cos( 4*t ) ) * 5;
                }
                else if(this.pathtype == "star"){
                    // Note these should be adjusted for different sized stars, ratio must be 5/3 though
                    var a = 50;
                    var b = 30;
                    this.cone.position.x = this.cx +( ((a-b)*Math.cos(t)) + b*Math.cos((a/b-1)*t) );
                    this.cone.position.y = this.cy +( ((a-b)*Math.sin(t)) - b*Math.sin((a/b-1)*t) );
                }
                else if(this.pathtype == "point"){
                    // No-op
                }
                this.sphere.position.x = this.cone.position.x;
                this.sphere.position.y = this.cone.position.y;
            };

            </script>
        </body>
    </html>      
